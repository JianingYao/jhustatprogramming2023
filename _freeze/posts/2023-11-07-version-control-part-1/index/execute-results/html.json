{
  "hash": "2560a93eb88226a871090770585e6bbb",
  "result": {
    "markdown": "---\ntitle: \"Version control (Part 1)\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Introduction to version control with git and GitHub (part 1)\"\ndate: 2023-11-07\ncategories: [module 1, week 3, version control, git, GitHub]\n---\n\n\n# Pre-lecture materials\n\n### Read ahead\n\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n-   [Software Carpentry: Version Control with Git](https://swcarpentry.github.io/git-novice/)\n:::\n\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   [Software Carpentry: Version Control with Git](https://swcarpentry.github.io/git-novice/)\n\n\n# Learning objectives\n\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Understand the benefits of an automated version control system.\n-   Understand how to set up git.\n-   Understand how to set up a git repository.\n-   Understand how to track changes, explore history, and ignore files in a git repository.\n:::\n\n\n# Introduction\n\n::: callout-note\n### Questions\n\n-   What is version control and why should I use it?\n:::\n\n\n::: callout-note\n### Objectives\n\n-   Understand the benefits of an automated version control system.\n-   Understand the basics of how automated version control systems work.\n:::\n\n\nWe will start by exploring how version control can be used to keep track of what one person did and when.\n\n## Overview\n\nFirst, a brief motivating example from Wolfman and Dracula. This story is from the [Version Control with Git](https://swcarpentry.github.io/git-novice/index.html) from Software Carpentry. \n\n![](../../images/git/motivatingexample.png)\n\n[[Source | Software Carpentry: Version Control with Git](https://swcarpentry.github.io/git-novice/index.html)]\n\n::: callout-tip\n### The story of Wolfman and Dracula\n\nWolfman and Dracula have been hired by Universal Missions (a space services spinoff from Euphoric State University) to investigate if it is possible to send their next planetary lander to Mars. They want to be able to work on the plans at the same time, but they have run into problems doing this in the past. If they take turns, each one will spend a lot of time waiting for the other to finish, but if they work on their own copies and email changes back and forth things will be lost, overwritten, or duplicated.\n\nA colleague suggests using **version control** to manage their work. Version control is better than mailing files back and forth:\n\n- **Nothing that is committed to version control is ever lost**, unless you work really, really hard at it. Since all old versions of files are saved, it’s always possible to go back in time to see exactly who wrote what on a particular day, or what version of a program was used to generate a particular set of results.\n\n- As we have this record of who made what changes when, we know who to ask if we have questions later on, and, if needed, **revert to a previous version, much like the \"undo\" feature** in an editor.\n\n- When several people collaborate in the same project, it is possible to accidentally overlook or overwrite someone’s changes. The version control system **automatically notifies users whenever there is a conflict** between one person's work and another's.\n:::\n\nTeams are not the only ones to benefit from version control: **lone researchers can benefit immensely**. Keeping a record of what was changed, when, and why is extremely useful for all researchers if they ever need to come back to the project later on (e.g., a year later, when memory has faded).\n\nAnother way of thinking about this: \n\n- **Version control is the lab notebook of the digital world**. It is what professionals use to keep track of what they have done and to collaborate with other people. Every large software development project relies on it, and most programmers use it for their small jobs as well. \n- It is **not just for software**: books, papers, small data sets, and anything that changes over time or needs to be shared can and should be stored in a version control system.\n\n## A common scenario\n\nWe have all been in this situation before: it seems unnecessary to have multiple nearly-identical versions of the same document. Some word processors let us deal with this a little better, such as Microsoft Word's Track Changes or Google Docs' version history.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![How not to use GitHub [image from PhD Comics]](../../images/phdversioncontrol.gif){width=80%}\n:::\n:::\n\n\n\\[[Source: PhD Comics](http://phdcomics.com/comics/archive_print.php?comicid=1531)\\]\n\n\n## git\n\n**Git** is what one type of a **version control system** for file management. The main idea is that as you (and your collaborators) work on a project, the software tracks, and records any changes made by anyone.\n\n-   Similar to the \"track changes\" features in Microsoft Word, but more rigorous, powerful, and scaled up to multiple files\n-   Great for solo or collaborative work\n- **Version control systems** start with **a base version** of the document and then **record changes you make each step of the way**.\n- For example, two users can make independent sets of changes on the same document.\n- Unless multiple users make changes to the same section of the document - a **conflict** - you can incorporate two sets of changes into the same base document.\n- It allows us to decide which changes will be made to the next version (each record of these changes is called a **commit**), and keeps useful metadata about them. \n- The complete history of commits for a particular project and their metadata make up a **repository**. \n- Repositories can be kept in sync across different computers, facilitating collaboration among different people.\n\n::: callout-tip\n### Terminology\n\n-   `commit`: a record of each set of changes in a document or file\n-   `repository`: the complete history of commits for a particular project and their metadata\n:::\n\n\n::: callout-important\n### Key Points\n\n-   Version control is like an unlimited 'undo'.\n-   Version control also allows many people to work in parallel.\n:::\n\n\n\n## GitHub\n\n**GitHub** is a hosting service on internet for git-aware folders and projects\n\n-   Similar to the DropBox or Google, but more structured, powerful, and programmatic\n-   Great for solo or collaborative work!\n-   Technically **GitHub** is distinct from **Git**. However, *GitHub* is in some sense the interface and *Git* the underlying engine (a bit like *RStudio* and *R*).\n\nSince we will only be using *Git* through *GitHub*, I tend to not distinguish between the two. In the following, I refer to all of it as just *GitHub*. Note that other interfaces to *Git* exist, e.g., *Bitbucket*, but *GitHub* is the most widely used one.\n\n::: callout-tip\n\nTo learn a bit more about Git/GitHub and why you might want to use it, [read this article by Jenny Bryan](https://peerj.com/preprints/3159/).\n\n**Note her explanation of what's special with the `README.md` file on GitHub.**\n\n::: \n\n::: callout-important\n\n### What to (not) do\n\n- **GitHub is ideal if** you have a project with a fair number of files, most of those files are text files (such as code, LaTeX, (R)markdown, etc.) and different people work on different parts of the project.\n\n- **GitHub is less useful if** you have a lot of non-text files (e.g. Word or Powerpoint) and different team members might want to edit the same document at the same time. In that instance, a solution like Google Docs, Word+Dropbox, Word+Onedrive, etc. might be better.\n\n:::\n\n::: callout-tip\n\n### How to use Git/GitHub\n\nGit and GitHub is fundamentally **based on commands you type into the command line**. Lots of online resources show you how to use the command line. This is the most powerful, and the way I almost always interact with git/GitHub. However, many folks find this the most confusing way to use git/GitHub. Alternatively, there are graphical interfaces.\n\n-   [GitHub itself](https://desktop.github.com/) provides a grapical interface with basic functionality.\n-   RStudio also has [Git/GitHub integration](https://happygitwithr.com/rstudio-git-github.html). Of course this only works for R project GitHub integration.\n-   There are also third party GitHub clients with many advanced features, most of which you won't need initially, but might eventually.\n\n:::\n\n::: callout-tip\n\n### Pro-tip\n\nAs student, you can (and should) upgrade to the Pro version of GitHub for free (i.e. access to unlimited private repositories is one benefit), see the [GitHub student developer pack](https://education.github.com/pack) on how to do this.\n\n:::\n\n## Getting started\n\nOne of my favorite resources for getting started with git/GitHub is the Happy Git with R from Jenny Bryan:\n\n-   <https://happygitwithr.com>\n\n\n::: {.cell}\n::: {.cell-output-display}\n![A screenshot of the Happy Git with R online book from Jenny Bryan](../../images/happygitwithr.png){width=80%}\n:::\n:::\n\n\nIt truly is one of the **best resources** out there for getting started with git/GitHub, especially with the integration to RStudio. Therefore, at this point, I will encourage all of you to go read through the online book.\n\nSome of you may only need to skim it, others will need to spend some time reading through it. Either way, I will bet that you won't regret the time investment.\n\n## Using git/GitHub in our course\n\nIn this course, you will use git/GitHub in the following ways:\n\n1.  Projects 2-4 - You will use git locally (on your compute environment) to track your changes over time and, you will push your project solutions to a private GitHub repository on GitHub Classroom (i.e. you will use the command-line commands `git add`, `git commit`, `git push`, `git pull`, etc) .\n\nLearning these skills will be useful down the road if you ever work collaboratively on a project (i.e. writing code as a group). In this scenario, you will use the skills you have been practicing in your projects to work together as a team in a single GitHub repository.\n\n\n\n\n# Setting Up Git\n\n::: callout-note\n### Questions\n\n-   How do I get set up to use Git?\n:::\n\n\n::: callout-note\n### Objectives\n\n-   Configure `git` the first time it is used on a computer.\n-   Understand the meaning of the `--global` configuration flag.\n:::\n\n\n## git config \n\nWhen we use Git on a new computer for the first time, we need to configure a few things:\n\n-   our name and email address\n-   what our preferred text editor is\n-   and that we want to use these settings globally (i.e. for every project).\n\nOn a command line, Git commands are written as `git verb options`, where `verb` is what we actually want to do and `options` is additional optional information.\n\nHere is how to set up Git on a new laptop:\n\n```bash\n$ git config --global user.name \"My Name\"\n$ git config --global user.email \"myemail@email.com\"\n```\n\nThis user name and email will be associated with your subsequent Git activity after this lecture.\n\n::: callout-important \n\nFor the lectures this week, we will be interacting with GitHub and so the email address used should be the same as the one used when setting up your GitHub account.\n:::\n\n## git config settings\n\nYou can check your settings at any time:\n\n```bash\n$ git config --list\n```\n\n\n::: callout-tip\n### Git Help and Manual\n\nIf you forget the options of a `git` command, you can type `git <command> -h` or access the corresponding Git manual by typing `git <command> --help`, e.g.:\n\n```bash\n$ git config -h\n$ git config --help\n```\n\nYou can press Q to exit the manual.\n\nYou can also get the list of available git commands and further resources of the Git manual typing:\n\n```bash\n$ git help\n```\n:::\n\n\n::: callout-important\n### Key Points\n\n-   Use `git config` with the `--global` option to configure a user name, email address, editor, and other preferences once per machine.\n:::\n\n\nNote that we will omit the `$` from shell commands shown from here onwards to make it easier to run them interactively in this tutorial.\n\n\n# Creating a Repository\n\n::: callout-note\n### Questions\n\n-   Where does Git store information?\n:::\n\n\n::: callout-note\n### Objectives\n\n-   Create a local Git repository.\n-   Describe the purpose of the `.git` directory.\n:::\n\n## git init\n\nOnce Git is configured, we can start using it.\n\nFirst, let's create a new directory in the Desktop folder for our work and then change the current working directory to the newly created one:\n\n```bash\ncd ~/Desktop\nmkdir planets\ncd planets\n```\n\n```bash\npwd\n```\n\n```default\n/Users/stephaniehicks/Desktop/planets\n```\n\nThen we tell Git to make `planets` a repository – a place where Git can store versions of our files:\n\n```bash\ngit init\n```\n\nNote that the creation of the `planets` directory and its initialization as a repository are completely separate processes.\n\nIf we use `ls` to show the directory's contents, it appears that nothing has changed:\n\n```bash\nls\n```\n\nBut if we add the `-a` flag to show everything, we can see that Git has created a hidden directory within planets called `.git`:\n\n```bash\nls -a\n```\n\n```default\n.\t..\t.git\n```\n\nGit uses this special subdirectory to store all the information about the project, including the tracked files and sub-directories located within the project's directory.\n\nIf we ever delete the `.git` subdirectory, we will lose the project's history.\n\nNext, we will change the default branch to be called `main.` This might be the default branch depending on your settings and version of git.\n\n```bash\ngit checkout -b main\n```\n\n```default\nSwitched to a new branch 'main'\n```\n\n## git status\n\nWe can check that everything is set up correctly by asking Git to tell us the status of our project:\n\n```bash\ngit status\n```\n\n```default\nOn branch main\n\nNo commits yet\n\nnothing to commit (create/copy files and use \"git add\" to track)\n```\n\n\n::: callout-note\n### Correcting `git init` Mistakes\n\nSuppose you have created the Git repository in the wrong directory, or made some other mistake.\n\nYou can delete the git repository by simply deleting the `.git` directory, either in Finder / Windows Explorer or from the command line:\n\n```bash\nrm -rf .git\n```\n\nBut **be careful**! Running this command in the wrong directory will remove the entire Git history of a project you might want to keep. Therefore, always check your current directory using the command `pwd`.\n:::\n\n\n::: callout-important\n### Key Points\n\n-   `git init` initializes a repository.\n-   Git stores all of its repository data in the `.git` directory.\n:::\n\n\n# Tracking Changes\n\n::: callout-note\n### Questions\n\n-   How do I record changes in Git?\n-   How do I check the status of my version control repository?\n-   How do I record notes about what changes I made and why?\n:::\n\n\n::: callout-note\n### Objectives\n-   Go through the modify-add-commit cycle for one or more files.\n-   Explain where information is stored at each stage of that cycle.\n-   Distinguish between descriptive and non-descriptive commit messages.\n:::\n\n\nFirst let's make sure we are still in the right directory. You should be in the `planets` directory.\n\n```bash\ncd ~/Desktop/planets\npwd\n```\n\n```default\n/Users/stephaniehicks/Desktop/planets\n```\n\n\n## git add \n\nLet's create a file called `mars.txt` that contains some notes about the Red Planet's suitability as a base.\n\nWe will use `touch` to create the file, and then open it in TextEdit or Notepad. Alternatively, you can use a command-line text editor such as `nano`.\n\n```bash\ntouch mars.txt\n```\n\nNow, open the `.txt` file and type the text below into the `mars.txt` file:\n\n```default\nCold and dry, but everything is my favorite color\n```\n\nLet's first verify that the file was properly created by running the list command (`ls`):\n\n```bash\nls\n```\n\n`mars.txt` contains a single line, which we can see by running:\n\n```bash\ncat mars.txt\n```\n\n```default\nCold and dry, but everything is my favorite color\n```\n\nIf we check the status of our project again, Git tells us that it's noticed the new file:\n\n```bash\ngit status\n```\n\n```default\nOn branch main\n\nNo commits yet\n\nUntracked files:\n   (use \"git add <file>...\" to include in what will be committed)\n\n\tmars.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n\nThe \"untracked files\" message means that there is a file in the directory that Git is not keeping track of. We can **tell Git to track a file** using `git add`:\n\n```bash\ngit add mars.txt\n```\n\nand then check that the right thing happened:\n\n```bash\ngit status\n```\n\n```default\nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n\n\tnew file:   mars.txt\n\n```\n\n## git commit \n\nGit now **knows that it is supposed to keep track** of `mars.txt`, but it has not recorded these changes as a commit yet. To get it to do that, we need to run one more command:\n\n```bash\ngit commit -m \"Start notes on Mars as a base\"\n```\n\n```default\n[main (root-commit) ef11b6d] Start notes on Mars as a base\n 1 file changed, 1 insertion(+)\n create mode 100644 mars.txt\n```\n\n::: callout-note \n\nWhen we run git commit, \n\n- Git takes everything we have told it to save by using `git add` and stores a copy permanently inside the special `.git` directory. \n- This permanent copy is called a commit (or revision) and its short identifier is `ef11b6d`. \n- Your commit may have another identifier.\n\n:::\n\n::: callout-tip\n\n### git commit message\n\nWe use the `-m` flag (for \"message\") to record a short, descriptive, and specific comment that will help us remember later on what we did and why. \n\nIf we just run `git commit` without the `-m` option, Git will launch `nano` (or whatever other editor is configured as `core.editor`) so that we can write a longer message.\n\n:::\n\nGood commit messages start with a brief (<50 characters) statement about the changes made in the commit. Generally, the message should complete the sentence \"If applied, this commit will\". If you want to go into more detail, add a blank line between the summary line and your additional notes. Use this additional space to explain why you made changes and/or what their impact will be.\n\nIf we run `git status` now:\n\n```bash\ngit status\n```\n\n```default\nOn branch main\nnothing to commit, working tree clean\n```\n\nit tells us everything is up to date. If we want to know what we've done recently, we can ask Git to show us the project's history using `git log`:\n\n```bash\ngit log\n```\n\n```\ncommit ef11b6d0b1181bcf34bed85e7d60e663e8bbde93 (HEAD -> main)\nAuthor: Stephanie Hicks <stephaniechicks@gmail.com>\nDate:   Sun Oct 29 22:12:47 2023 -0400\n\n    Start notes on Mars as a base\n```\n\n`git log` lists all commits made to a repository in reverse chronological order.\n\n\n## Adding changes to a file\n\nNow suppose we add more information to the file. (Again, we will edit with TextEdit / Notepad and then `cat` the file to show its contents.)\n\nPaste the following second line into the file:\n\n```default\nCold and dry, but everything is my favorite color\nThe two moons may be a problem for Wolfman\n```\n\nWhen we run `git status` now, it tells us that a file it already knows about has been modified:\n\n```bash\ngit status\n```\n\n```default\nOn branch main\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   mars.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\nThe last line is the key phrase: \"no changes added to commit\". We have changed this file, but we have not told Git we will want to save those changes (which we do with `git add`) nor have we saved them (which we do with `git commit`).\n\nSo let's do that now. It is good practice to always review our changes before saving them. We do this using `git diff`. This shows us the differences between the current state of the file and the most recently saved version:\n\n```bash\ngit diff\n```\n\n```default\ndiff --git a/mars.txt b/mars.txt\nindex bd9fd42..6967aea 100644\n--- a/mars.txt\n+++ b/mars.txt\n@@ -1 +1,2 @@\n Cold and dry, but everything is my favorite color\n+The two moons may be a problem for Wolfman\n```\n\nThe output is cryptic because it is actually a series of commands for tools like editors and `patch` telling them how to reconstruct one file given the other.\n\nAfter reviewing our change, it's time to commit it:\n\n```bash\ngit commit -m \"Add concerns about effects of Mars' moons on Wolfman\"\n```\n\n```default\nOn branch main\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   mars.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\nWhoops: Git will no commit because we did not use `git add` first. Let's fix that:\n\n```bash\ngit add mars.txt\ngit commit -m \"Add concerns about effects of Mars' moons on Wolfman\"\n```\n\n```default\n[main 5635827] Add concerns about effects of Mars' moons on Wolfman\n 1 file changed, 1 insertion(+)\n```\n\n\n## Staging area\n\nGit insists that we add files to the set we want to commit before actually committing anything. This allows us to commit our changes in stages and capture changes in logical portions rather than only large batches.\n\nTo allow for this, Git has a special staging area where it keeps track of things that have been added but not yet committed.\n\n\n::: callout-note\n### Staging Area\n\nIf you think of Git as taking snapshots of changes over the life of a project, `git add` specifies what will go in a snapshot (putting things in the staging area), and `git commit` then actually takes the snapshot, and makes a permanent record of it (as a commit).\n\nIf you do not have anything staged when you type git commit, Git will prompt you to use `git commit -a` or `git commit --all`, which will add all files. However, it's almost always better to explicitly add things to the staging area, because you might commit changes you forgot you made.\n\nTry to stage things manually, or you might find yourself searching for \"git undo commit\" more than you would like!\n:::\n\n\nLet's watch as our changes to a file move from our editor to the staging area and into long-term storage. First, we'll add another line to the file:\n\n```bash\ncat mars.txt\n```\n\n```default\nCold and dry, but everything is my favorite color\nThe two moons may be a problem for Wolfman\nBut the Mummy will appreciate the lack of humidity\n```\n\n```bash\ngit diff\n```\n\n```default\ndiff --git a/mars.txt b/mars.txt\nindex 6967aea..b36abfd 100644\n--- a/mars.txt\n+++ b/mars.txt\n@@ -1,2 +1,3 @@\n Cold and dry, but everything is my favorite color\n The two moons may be a problem for Wolfman\n+But the Mummy will appreciate the lack of humidity\n```\n\nSo far, so good: we've added one line to the end of the file (shown with a `+` in the first column). Now let's put that change in the staging area and see what `git diff` reports:\n\n```bash\ngit add mars.txt\ngit diff\n```\n\nThere is no output: as far as Git can tell, there's no difference between what it's been asked to save permanently and what's currently in the directory. However, if we do this:\n\n```bash\ngit diff --staged\n```\n\n```default\ndiff --git a/mars.txt b/mars.txt\nindex 6967aea..b36abfd 100644\n--- a/mars.txt\n+++ b/mars.txt\n@@ -1,2 +1,3 @@\n Cold and dry, but everything is my favorite color\n The two moons may be a problem for Wolfman\n+But the Mummy will appreciate the lack of humidity\n```\n\nit shows us the difference between the last committed change and what's in the staging area. Let's save our changes:\n\n```bash\ngit commit -m \"Discuss concerns about Mars' climate for Mummy\"\n```\n\n```default\n[main e86c8f6] Discuss concerns about Mars' climate for Mummy\n 1 file changed, 1 insertion(+)\n```\n\ncheck our status:\n\n```bash\ngit status\n```\n\n```default\nOn branch main\nnothing to commit, working tree clean\n```\n\nand look at the history of what we've done so far:\n\n```bash\ngit log\n```\n\n```default\ncommit e86c8f6fdb53a390a5dfea6f9f9052f05fd35baa (HEAD -> main)\nAuthor: Stephanie Hicks <stephaniechicks@gmail.com>\nDate:   Sun Oct 29 23:27:34 2023 -0400\n\n    Discuss concerns about Mars' climate for Mummy\n\ncommit 563582798a711c58c0f23555c452685c71fd4c4e\nAuthor: Stephanie Hicks <stephaniechicks@gmail.com>\nDate:   Sun Oct 29 23:23:16 2023 -0400\n\n    Add concerns about effects of Mars' moons on Wolfman\n\ncommit ef11b6d0b1181bcf34bed85e7d60e663e8bbde93\nAuthor: Stephanie Hicks <stephaniechicks@gmail.com>\nDate:   Sun Oct 29 23:12:47 2023 -0400\n\n    Start notes on Mars as a base\n```\n\n\n::: callout-note\n### Word-based diffing\n\nSometimes, e.g. in the case of the text documents a line-wise diff is too coarse. That is where the `--color-words` option of `git diff` comes in very useful as it highlights the changed words using colors.\n:::\n\n\n::: callout-note\n### Paging the Log\n\nIf the output of `git log` is too long to fit in your screen, Git splits it into pages.\n\nTo get out of the pager, press `Q`.\n\nTo move to the next page, press `Spacebar`.\n:::\n\n\n## Directories\n\nTwo important facts you should know about directories in Git.\n\nFirst, Git does not track directories on their own, only files within them. Try it for yourself:\n\n```bash\nmkdir spaceships\ngit status\ngit add spaceships\ngit status\n```\n\n```default\nOn branch main\nnothing to commit, working tree clean\n```\n\nNote, our newly created empty directory `spaceships` does not appear in the list of untracked files even if we explicitly add it (via `git add`) to our repository.\n\n\nSecond, if you create a directory in your Git repository and populate it with files, you can add all files in the directory at once by:\n\n```bash\ngit add <directory-with-files>\n```\n\nTry it for yourself:\n\n```bash\ntouch spaceships/apollo-11 spaceships/sputnik-1\ngit status\ngit add spaceships\ngit status\n```\n\n```default\nOn branch main\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n        new file:   spaceships/apollo-11\n        new file:   spaceships/sputnik-1\n\n```\n\nBefore moving on, we will commit these changes.\n\n```bash\ngit commit -m \"Add some initial thoughts on spaceships\"\n```\n\n```default\n[main ac23fe8] Add some initial thoughts on spaceships\n 2 files changed, 0 insertions(+), 0 deletions(-)\n create mode 100644 spaceships/apollo-11\n create mode 100644 spaceships/sputnik-1\n```\n\nTo recap, when we want to add changes to our repository, we first need to add the changed files to the staging area (`git add`) and then commit the staged changes to the repository (`git commit`).\n\nFor a visualization of this workflow, see the [Software Carpentry: Version Control with Git](https://swcarpentry.github.io/git-novice/04-changes.html#directories) page.\n\n\n## Exercises\n\n::: callout-tip\n### Choosing a Commit Message\n\nWhich of the following commit messages would be most appropriate for the last commit made to `mars.txt`?\n\n1. \"Changes\"\n2. \"Added line 'But the Mummy will appreciate the lack of humidity' to mars.txt\"\n3. \"Discuss effects of Mars' climate on the Mummy\"\n:::\n\n\n::: callout-tip\n### Committing Changes to Git\n\nWhich command(s) below would save the changes of `myfile.txt` to my local Git repository?\n\n```bash\ngit commit -m \"my recent changes\"\n```\n\n```bash\ngit init myfile.txt\ngit commit -m \"my recent changes\"\n```\n\n```bash\ngit add myfile.txt\ngit commit -m \"my recent changes\"\n```\n\n```bash\ngit commit -m myfile.txt \"my recent changes\"\n```\n:::\n\n\nAdditional exercises are available on the [Software Carpentry: Version Control with Git](https://swcarpentry.github.io/git-novice/04-changes.html#choosing-a-commit-message) page.\n\n\n::: callout-important\n### Key Points\n\n-   `git status` shows the status of a repository.\n-   Files can be stored in a project's working directory (which users see), the staging area (where the next commit is being built up) and the local repository (where commits are permanently recorded).\n-   `git add` puts files in the staging area.\n-   `git commit` saves the staged content as a new commit in the local repository.\n-   Write a commit message that accurately describes your changes.\n:::\n\n\n# Exploring History\n\n::: callout-note\n### Questions\n\n- How can I identify old versions of files?\n- How do I review my changes?\n- How can I recover old versions of files?\n:::\n\n\n::: callout-note\n### Objectives\n\n- Explain what the HEAD of a repository is and how to use it.\n- Identify and use Git commit numbers.\n- Compare various versions of tracked files.\n- Restore old versions of files.\n:::\n\n\nAs we saw in the previous episode, we can refer to commits by their identifiers. You can refer to the _most recent commit_ of the working directory by using the identifier `HEAD`.\n\nLet's make a change to mars.txt, adding yet another line.\n\n```bash\ncat mars.txt\n```\n\n```default\nCold and dry, but everything is my favorite color\nThe two moons may be a problem for Wolfman\nBut the Mummy will appreciate the lack of humidity\nAn ill-considered change\n```\n\nNow, let's see what we get.\n\n```bash\ngit diff HEAD mars.txt\n```\n\n```default\ndiff --git a/mars.txt b/mars.txt\nindex b36abfd..93a3e13 100644\n--- a/mars.txt\n+++ b/mars.txt\n@@ -1,3 +1,4 @@\n Cold and dry, but everything is my favorite color\n The two moons may be a problem for Wolfman\n But the Mummy will appreciate the lack of humidity\n+An ill-considered change\n```\n\nwhich is the same as what you would get if you leave out `HEAD` (try it).\n\nYou can refer to previous commits by adding `~1` (where \"~\" is \"tilde\") to refer to the commit one before `HEAD`.\n\n```bash\ngit diff HEAD~1 mars.txt\n```\n\nIf we want to see the differences between older commits we can use `git diff` again, but with the notation `HEAD~1`, `HEAD~2`, and so on, to refer to them:\n\n```bash\ngit diff HEAD~3 mars.txt\n```\n\n```default\ndiff --git a/mars.txt b/mars.txt\nindex df0654a..93a3e13 100644\n--- a/mars.txt\n+++ b/mars.txt\n@@ -1 +1,4 @@\n Cold and dry, but everything is my favorite color\n+The two moons may be a problem for Wolfman\n+But the Mummy will appreciate the lack of humidity\n+An ill-considered change\n```\n\nWe could also use `git show` which shows us what changes we made at an older commit as well as the commit message, rather than the differences between a commit and our working directory that we see by using `git diff`.\n\n```bash\ngit show HEAD~3 mars.txt\n```\n\n```default\ncommit ef11b6d0b1181bcf34bed85e7d60e663e8bbde93\nAuthor: Stephanie Hicks <stephaniechicks@gmail.com>\nDate:   Sun Oct 29 23:12:47 2023 -0400\n\n    Start notes on Mars as a base\n\ndiff --git a/mars.txt b/mars.txt\nnew file mode 100644\nindex 0000000..bd9fd42\n--- /dev/null\n+++ b/mars.txt\n@@ -0,0 +1 @@\n+Cold and dry, but everything is my favorite color\n```\n\nIn this way, we can build up a chain of commits. The most recent end of the chain is referred to as `HEAD`; we can refer to previous commits using the `~` notation, so `HEAD~1` means \"the previous commit\".\n\nWe can also refer to commits using those long strings of digits and letters that `git log` displays. These are unique IDs for the changes, and \"unique\" really does mean unique: every change to any set of files on any computer has a unique 40-character identifier. Our first commit was given the ID `ef11b6d0b1181bcf34bed85e7d60e663e8bbde93`, so let’s try this:\n\n```bash\ngit diff ef11b6d0b1181bcf34bed85e7d60e663e8bbde93 mars.txt\n```\n\n```default\ndiff --git a/mars.txt b/mars.txt\nindex bd9fd42..93a3e13 100644\n--- a/mars.txt\n+++ b/mars.txt\n@@ -1 +1,4 @@\n Cold and dry, but everything is my favorite color\n+The two moons may be a problem for Wolfman\n+But the Mummy will appreciate the lack of humidity\n+An ill-considered change\n```\n\nGit lets us use just the first few characters (typically seven):\n\n```bash\ngit diff ef11b6d mars.txt\n```\n\n```default\ndiff --git a/mars.txt b/mars.txt\nindex bd9fd42..93a3e13 100644\n--- a/mars.txt\n+++ b/mars.txt\n@@ -1 +1,4 @@\n Cold and dry, but everything is my favorite color\n+The two moons may be a problem for Wolfman\n+But the Mummy will appreciate the lack of humidity\n+An ill-considered change\n```\n\n\n## Restoring older versions\n\nAll right! So we can save changes to files and see what we've changed.\n\nNow, how can we restore older versions of things? Let's suppose we change our mind about the last update to `mars.txt`.\n\n`git status` now tells us that the file has been changed, but those changes have not been staged:\n\n```bash\ngit status\n```\n\n```default\nOn branch main\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   mars.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\nWe can put things back the way they were by using `git checkout`:\n\n```bash\ngit checkout HEAD mars.txt\ncat mars.txt\n```\n\n```default\nCold and dry, but everything is my favorite color\nThe two moons may be a problem for Wolfman\nBut the Mummy will appreciate the lack of humidity\n```\n\nAs you might guess from its name, `git checkout` checks out (i.e., restores) an old version of a file. In this case, we are telling Git that we want to recover the version of the file recorded in `HEAD`, which is the last saved commit.\n\nIf we want to go back even further, we can use a commit identifier instead:\n\n```bash\ngit checkout ef11b6d mars.txt\n```\n\n```default\nUpdated 1 path from 3e62de1\n```\n\n```bash\ncat mars.txt\n```\n\n```default\nCold and dry, but everything is my favorite color\n```\n\n```bash\ngit status\n```\n\n```default\nOn branch main\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n        modified:   mars.txt\n\n```\n\nNotice that the changes are currently in the staging area. Again, we can put things back the way they were by using git checkout:\n\n```bash\ngit checkout HEAD mars.txt\n```\n\n```default\nUpdated 1 path from aab57ac\n```\n\n\n::: callout-warning\n### Don't Lose Your HEAD\n\nAbove we used\n\n```bash\ngit checkout ef11b6d mars.txt\n```\n\nto revert `mars.txt` to its state after the commit `ef11b6d`.\n\nBut be careful! The command `checkout` has other important functionalities and Git will misunderstand your intentions if you are not accurate with the typing.\n\nFor example, if you forget `mars.txt` in the previous command.\n\n```bash\ngit checkout ef11b6d\n```\n\n```default\nNote: switching to 'ef11b6d'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by switching back to a branch.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -c with the switch command. Example:\n\n  git switch -c <new-branch-name>\n\nOr undo this operation with:\n\n  git switch -\n\nTurn off this advice by setting config variable advice.detachedHead to false\n\nHEAD is now at ef11b6d Start notes on Mars as a base\n```\n\nThe \"detached HEAD\" state lets you look around without the repository without making any changes, so you shouldn't make any changes in this state. After investigating your repository's past state, reattach your `HEAD` with `git checkout main`.\n\n```bash\ngit checkout main\n```\n\n```default\nPrevious HEAD position was ef11b6d Start notes on Mars as a base\nSwitched to branch 'main'\n```\n:::\n\n\n::: callout-note\n### Sequence of commits\n\nIt's important to remember that we must use the commit number that identifies the state of the repository _before_ the change we're trying to undo. A common mistake is to use the number of the commit in which we made the change we're trying to discard.\n:::\n\n\nFor some additional visualizations, see the [Software Carpentry: Version Control with Git](https://swcarpentry.github.io/git-novice/05-history.html#dont-lose-your-head) page.\n\n\n::: callout-note\n### Simplifying the Common Case\n\nIf you read the output of `git status` carefully, you will see that it includes this hint:\n\n```default\n(use \"git checkout -- <file>...\" to discard changes in working directory)\n```\n\nAs it says, `git checkout` without a version identifier restores files to the state saved in `HEAD.` The double dash `--` is needed to separate the names of the files being recovered from the command itself: without it, Git would try to use the name of the file as the commit identifier.\n:::\n\n\nThe fact that files can be reverted one by one tends to change the way people organize their work. If everything is in one large document, it is hard (but not impossible) to undo changes to the introduction without also undoing changes made later to the conclusion. If the introduction and conclusion are stored in separate files, on the other hand, moving backward and forward in time becomes much easier.\n\n\n## Exercises\n\n::: callout-tip\n### Recovering Older Versions of a File\n\nJennifer has made changes to the R script that she has been working on for weeks, and the modifications she made this morning \"broke\" the script and it no longer runs. She has spent ~ 1hr trying to fix it, with no luck...\n\nLuckily, she has been keeping track of her project's versions using Git! Which commands below will let her recover the last committed version of her R script called `data_cruncher.R`?\n\n1.    `git checkout HEAD`\n2.    `git checkout HEAD data_cruncher.R`\n3.    `git checkout HEAD~1 data_cruncher.R`\n4.    `git checkout <unique ID of last commit> data_cruncher.R`\n5.    Both 2 and 4\n:::\n\n\n::: callout-tip\n### Reverting a Commit\n\nJennifer is collaborating with colleagues on her R script. She realizes her last commit to the project's repository contained an error, and wants to undo it. Jennifer wants to undo correctly so everyone in the project's repository gets the correct change. The command `git revert [erroneous commit ID]` will create a new commit that reverses the erroneous commit.\n\nThe command `git revert` is different from `git checkout [commit ID]` because `git checkout` returns the files not yet committed within the local repository to a previous state, whereas git revert reverses changes committed to the local and project repositories.\n\nBelow are the right steps and explanations for Jennifer to use `git revert`, what is the missing command?\n\n1.    `________ # Look at the git history of the project to find the commit ID`\n2.    Copy the ID (the first few characters of the ID, e.g. `0b1d055`).\n3.    `git revert [commit ID]`\n4.    Type in the new commit message.\n5.    Save and close\n:::\n\n\n::: callout-tip\n### Checking Understanding of `git diff`\n\nConsider this command: `git diff HEAD~9 mars.txt`. What do you predict this command will do if you execute it? What happens when you do execute it? Why?\n\nTry another command, `git diff [ID] mars.txt`, where `[ID]` is replaced with the unique identifier for your most recent commit. What do you think will happen, and what does happen?\n:::\n\n\nAdditional exercises are available on the [Software Carpentry: Version Control with Git](https://swcarpentry.github.io/git-novice/05-history.html#recovering-older-versions-of-a-file) page.\n\n\n::: callout-important\n### Key Points\n\n-   `git diff` displays differences between commits.\n-   `git checkout` recovers old versions of files.\n:::\n\n\n# Ignoring Things\n\n::: callout-note\n### Questions\n\n-   How can I tell Git to ignore files I do not want to track?\n:::\n\n\n::: callout-note\n### Objectives\n\n-   Configure Git to ignore specific files.\n-   Explain why ignoring files can be useful.\n:::\n\n\nWhat if we have files that we do not want Git to track for us, like backup files created by our editor or intermediate files created during data analysis? Let's create a few dummy files:\n\n```bash\nmkdir results\ntouch a.dat b.dat c.dat results/a.out results/b.out\n```\n\nand see what Git says:\n\n```bash\ngit status\n```\n\n```default\nOn branch main\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\ta.dat\n\tb.dat\n\tc.dat\n\tresults/\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n\nPutting these files under version control would be a waste of disk space. What's worse, having them all listed could distract us from changes that actually matter, so let's tell Git to ignore them.\n\nWe do this by creating a file in the root directory of our project called `.gitignore`:\n\n```bash\ntouch .gitignore\n```\n\nOpen the file in TextEdit / Notepad, or alternatively from the command line using `nano`.\n\nNote this is a hidden file (filename beginning with `.`), so you will need to enable Finder / Windows Explorer to show hidden files.\n\nAdd the following lines in the `.gitignore` file and save it.\n\n```default\n*.dat\nresults/\n```\n\n```bash\ncat .gitignore\n```\n\nThese patterns tell Git to ignore any file whose name ends in `.dat` and everything in the `results` directory.\n\n::: callout-warning\n### Adding existing files in `.gitignore`\n\nNote that if any of these files were already being tracked, Git would continue to track them.\n:::\n\n\nOnce we have created this file, the output of `git status` is much cleaner:\n\n```bash\ngit status\n```\n\n```default\nOn branch main\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\t.gitignore\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n\nThe only thing Git notices now is the newly-created `.gitignore` file. You might think we wouldn't want to track it, but everyone we're sharing our repository with will probably want to ignore the same things that we're ignoring. Let's add and commit `.gitignore`:\n\n```bash\ngit add .gitignore\ngit commit -m \"Ignore data files and the results folder.\"\ngit status\n```\n\n```default\nOn branch main\nnothing to commit, working tree clean\n```\n\nAs a bonus, using `.gitignore` helps us avoid accidentally adding files to the repository that we don't want to track:\n\n```bash\ngit add a.dat\n```\n\n```default\nThe following paths are ignored by one of your .gitignore files:\na.dat\nUse -f if you really want to add them.\n```\n\nIf we really want to override our ignore settings, we can use `git add -f` to force Git to add something. For example, `git add -f a.dat`. We can also always see the status of ignored files if we want:\n\n```bash\ngit status --ignored\n```\n\n```default\nOn branch main\nIgnored files:\n (use \"git add -f <file>...\" to include in what will be committed)\n\n        a.dat\n        b.dat\n        c.dat\n        results/\n\nnothing to commit, working tree clean\n```\n\n\n## Exercises\n\n::: callout-tip\n### Ignoring Nested Files\n\nGiven a directory structure that looks like:\n\n```default\nresults/data\nresults/plots\n```\n\nHow would you ignore only `results/plots` and not `results/data`?\n:::\n\n\n::: callout-tip\n### Including Specific Files\n\nHow would you ignore all `.dat` files in your root directory except for `final.dat`?\n\nHint: Find out what `!` (the exclamation point operator) does.\n\nThe exclamation point operator will include a previously excluded entry.\n:::\n\n\n::: callout-tip\n### Ignoring all data Files in a Directory\n\nAssuming you have an empty `.gitignore` file, and given a directory structure that looks like:\n\n```default\nresults/data/position/gps/a.dat\nresults/data/position/gps/b.dat\nresults/data/position/gps/c.dat\nresults/data/position/gps/info.txt\nresults/plots\n```\n\nWhat's the shortest `.gitignore` rule you could write to ignore all `.dat` files in `result/data/position/gps`? Do not ignore the `info.txt`.\n:::\n\n\n::: callout-tip\n### Ignoring all data Files in the repository\n\nLet us assume you have many `.dat` files in different subdirectories of your repository. For example, you might have:\n\n```default\nresults/a.dat\ndata/experiment_1/b.dat\ndata/experiment_2/c.dat\ndata/experiment_2/variation_1/d.dat\n```\n\nHow do you ignore all the `.dat` files, without explicitly listing the names of the corresponding folders?\n:::\n\n\nAdditional exercises are available on the [Software Carpentry: Version Control with Git](https://swcarpentry.github.io/git-novice/06-ignore.html#ignoring-nested-files) page.\n\n\n::: callout-important\n### Key Points\n\n-   The `.gitignore` file tells Git what files to ignore.\n:::\n\n\n# Post-lecture materials\n\n## Preparation for next lesson\n\nIn the next lesson, we will learn how to use git remotes and GitHub. As preparation, you can sign up for a [GitHub](https://github.com/) account if you do not already have one.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}